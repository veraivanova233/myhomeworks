#include <algorithm>
#include <iostream>
#include <map>
#include <string>
#include <utility>
#include <vector>

template<typename MyCl>
class Polynomial {
private:
    std::vector<MyCl> mydata;

    void delete_null(std::vector<MyCl> &coeff) {
        for (int i = coeff.size() - 1; i > -1; --i) {
            if (coeff[i] == MyCl(0)) {
                coeff.erase(coeff.begin() + i);
            } else {
                break;
            }
        }
    }

public:
    std::vector<MyCl> get_data() const {
        return mydata;
    }

    Polynomial<MyCl>(const std::vector<MyCl> &input) : mydata(input) {
        delete_null(mydata);
    }

    template<typename Iter>
    Polynomial<MyCl>(Iter first, Iter last) :mydata(first, last) {
        delete_null(mydata);
    }

    Polynomial<MyCl>(MyCl x = MyCl(0)) {
        if (x != MyCl(0)) {
            mydata.push_back(x);
        }
    }

    MyCl operator[](size_t i) const {
        if (i >= mydata.size()) {
            return MyCl(0);
        } else {
            return mydata[i];
        }
    }

    int Degree() const {
        if (mydata.size() == 0) {
            return -1;
        } else {
            return static_cast<int>(mydata.size()) - 1;
        }
    }

   friend bool operator==(const Polynomial<MyCl> &self, const Polynomial<MyCl> &other) {
        return self.mydata == other.mydata;
    }

    friend bool operator!=(const Polynomial<MyCl> &self, const Polynomial<MyCl> &other) {
        return !(self.mydata == other.mydata);
    }

    Polynomial<MyCl> &operator+=(const Polynomial<MyCl> &other) {
        size_t count = 0;
        if (mydata.size() < other.mydata.size()) {
            mydata.resize(other.mydata.size(), MyCl(0));
        }
        while (count < other.mydata.size()) {
            mydata[count] += other.mydata[count];
            count += 1;
        }
        delete_null(mydata);
        return *this;
    }

    Polynomial<MyCl> &operator-=(const Polynomial<MyCl> &other) {
        size_t count = 0;
        if (mydata.size() < other.mydata.size()) {
            mydata.resize(other.mydata.size(), MyCl(0));
        }
        while (count < other.mydata.size()) {
            mydata[count] -= other.mydata[count];
            count += 1;
        }
        delete_null(mydata);
        return *this;
    }

    Polynomial<MyCl> &operator+=(const MyCl &scal) {
        *this += Polynomial<MyCl>(scal);
        delete_null(mydata);
        return *this;
    }

    Polynomial<MyCl> &operator-=(const MyCl &scal) {
        *this -= Polynomial<MyCl>(scal);
        delete_null(mydata);
        return *this;
    }

    Polynomial<MyCl> &operator*=(const Polynomial<MyCl> &other) {
        std::vector<MyCl> mult(mydata.size() + other.mydata.size(), MyCl(0));
        for (size_t i = 0; i != mydata.size(); ++i) {
            for (size_t j = 0; j != other.mydata.size(); ++j) {
                mult[i + j] += mydata[i] * other.mydata[j];
            }
        }
        delete_null(mult);
        *this = Polynomial(mult);
        return *this;
    }

    Polynomial<MyCl> &operator*=(const MyCl &scal) {
        for (size_t i = 0; i != mydata.size(); ++i) {
            mydata[i] *= scal;
        }
        delete_null(mydata);
        return *this;
    }

    MyCl operator()(const MyCl &point) const {
        MyCl res = MyCl(0);
        for (auto coeff = mydata.rbegin(); coeff != mydata.rend(); ++coeff) {
            res += *coeff;
            if ((coeff + 1) != mydata.rend()) {
                res *= point;
            }
        }
        return res;
    }

    friend std::ostream &operator<<(std::ostream &os, const Polynomial<MyCl> &polynom) {
        int count = 0;
        auto pow = polynom.mydata.size() - 1;
        for (auto iter = polynom.mydata.rbegin(); iter != polynom.mydata.rend(); ++iter, --pow) {
            MyCl coeff = *iter;
            if (coeff != MyCl(0)) {
                if (coeff > MyCl(0) && count != 0) {
                    os << '+';
                }
                if (pow == 0) {
                    os << coeff;
                } else if (coeff == MyCl(1)) {
                    os << 'x';
                } else if (coeff == MyCl(-1)) {
                    os << "-x";
                } else {
                    os << coeff << "*x";
                }
                if (pow > 1) {
                    os << '^' << pow;
                }
                count += 1;
            }
        }
        if (polynom.mydata.size() == 0) {
            os << 0;
        }
        return os;
    }

    friend Polynomial<MyCl> operator&(const Polynomial<MyCl> &left, const Polynomial<MyCl> &right) {
        Polynomial<MyCl> composition(left.mydata[0]);
        size_t i = 1;
        Polynomial<MyCl> copy(right.mydata);
        for (size_t pow = 1; pow < left.mydata.size(); ++pow) {
            for (; i < pow; ++i) {
                copy *= right;
            }
            composition += copy * left.mydata[pow];
        }
        return composition;
    }
    Polynomial<MyCl> &operator/=(const Polynomial<MyCl> &other) {
        Polynomial<MyCl> result(MyCl(0));
        while (mydata.size() >= other.mydata.size()) {
            size_t pow = (mydata.size() - 1) - (other.mydata.size() - 1);
            std::vector<MyCl> vec(pow + 1);
            MyCl coeff = mydata[mydata.size() - 1] / other.mydata[other.mydata.size() - 1];
            vec[vec.size() - 1] = coeff;
            Polynomial<MyCl> div(vec);
            *this -= other * div;
            result += div;
        }
        mydata = result.mydata;
        return *this;
    }

    Polynomial<MyCl> &operator%=(const Polynomial<MyCl> &other) {
        Polynomial<MyCl> res = *this / other;
        *this -= res * other;
        return *this;

    }

    friend Polynomial<MyCl> operator,(const Polynomial<MyCl> &self, const Polynomial<MyCl> &other) {
        Polynomial<MyCl> gcd = self;
        Polynomial<MyCl> denom = other;
        if (self.mydata.size() != 0) {
            while (denom.mydata.size() != 0) {
                gcd %= denom;
                auto p = gcd;
                gcd = denom;
                denom = p;
            }
            Polynomial<MyCl> div(gcd[gcd.mydata.size() - 1]);
            gcd /= div;
        }
        return gcd;
    }

    typename std::vector<MyCl>::const_iterator begin() const {
        return mydata.begin();
    }

    typename std::vector<MyCl>::const_iterator end() const {
        return mydata.end();
    }
};

template<typename MyCl>
Polynomial<MyCl> operator*(Polynomial<MyCl> self, const Polynomial<MyCl> &other) {
    return self *= other;
}

template<typename MyCl>
Polynomial<MyCl> operator*(Polynomial<MyCl> res, const MyCl &scal) {
    return res *= Polynomial<MyCl>(scal);
}

template<typename MyCl>
Polynomial<MyCl> operator*(const MyCl &scal, Polynomial<MyCl> res) {
    return res *= Polynomial<MyCl>(scal);
}

template<typename MyCl>
Polynomial<MyCl> operator+(Polynomial<MyCl> self, const Polynomial<MyCl> &other) {
    return self += other;
}

template<typename MyCl>
Polynomial<MyCl> operator+(Polynomial<MyCl> res, const MyCl &scal) {
    return res += Polynomial<MyCl>(scal);
}

template<typename MyCl>
Polynomial<MyCl> operator+(const MyCl &scal, Polynomial<MyCl> res) {
    return res += Polynomial<MyCl>(scal);
}

template<typename MyCl>
Polynomial<MyCl> operator-(Polynomial<MyCl> self, const Polynomial<MyCl> &other) {
    return self -= other;
}

template<typename MyCl>
Polynomial<MyCl> operator-(Polynomial<MyCl> res, const MyCl &scal) {
    return res -= Polynomial<MyCl>(scal);
}

template<typename MyCl>
Polynomial<MyCl> operator-(const MyCl &scal, Polynomial<MyCl> res) {
    return Polynomial<MyCl>(scal) -= res;
}

template<typename MyCl>
Polynomial<MyCl> operator/(const Polynomial<MyCl> &self, const Polynomial<MyCl> &other) {
    auto res = self;
    res /= other;
    return res;
}

template<typename MyCl>
Polynomial<MyCl> operator%(const Polynomial<MyCl> &self, const Polynomial<MyCl> &other) {
    auto res = self;
    res %= other;
    return res;
}

